# 종목 스캔 기능 구현 요청

## 목표
업비트 코인 종목을 3가지 전략(V1/V2/V3)으로 스캔하여 매수/매도 신호를 화면에 표시하는 기능을 구현해줘.

---

## 1. 백엔드 구현

### 1-1. 업비트 API 클라이언트 구현

**파일 위치:** `src/main/java/com/cryptobot/upbit/upbit/UpbitApiClient.java`

**구현 기능:**
- 전체 마켓 코드 조회 (KRW 마켓만 필터링)
- 5분봉 캔들 데이터 조회 (최근 200개)
- 15분봉 캔들 데이터 조회 (최근 200개)

**사용할 업비트 API:**
```
GET https://api.upbit.com/v1/market/all
GET https://api.upbit.com/v1/candles/minutes/5?market={market}&count=200
GET https://api.upbit.com/v1/candles/minutes/15?market={market}&count=200
```

**구현 요구사항:**
- WebClient를 사용한 비동기 호출
- 타임아웃 5초 설정
- 재시도 로직 포함 (최대 3회)
- 응답 DTO 생성 필요

**생성할 DTO 파일:**
- `src/main/java/com/cryptobot/upbit/upbit/dto/UpbitMarketResponse.java`
- `src/main/java/com/cryptobot/upbit/upbit/dto/UpbitCandleResponse.java`

**UpbitCandleResponse 구조:**
```java
public class UpbitCandleResponse {
    private String market;                    // 마켓명 (KRW-BTC)
    private String candle_date_time_kst;      // 캔들 기준 시각 (KST)
    private Double opening_price;             // 시가
    private Double high_price;                // 고가
    private Double low_price;                 // 저가
    private Double trade_price;               // 종가
    private Double candle_acc_trade_volume;   // 거래량
}
```

---

### 1-2. 지표 계산 엔진 구현

**파일 위치:** `src/main/java/com/cryptobot/upbit/indicator/`

#### 메인 엔진
**파일:** `IndicatorEngine.java`

통합 인터페이스 제공, 각 계산기를 조합하여 사용

#### 개별 계산기 구현

**1) EMA (Exponential Moving Average)**
- 파일: `EmaCalculator.java`
- 메서드: `static List<Double> calculate(List<Double> closes, int length)`
- 알고리즘: 지수 이동 평균
- 워밍업: 3 × length 봉 필요

**2) RSI (Relative Strength Index)**
- 파일: `RsiCalculator.java`
- 메서드: `static List<Double> calculate(List<Double> closes, int length)`
- 알고리즘: Wilder's smoothing 방식
- 워밍업: 3 × length 봉 필요 (14일 기준 42봉)
- oversold: 30, overbought: 70

**3) MACD (Moving Average Convergence Divergence)**
- 파일: `MacdCalculator.java`
- 메서드: `static MacdResult calculate(List<Double> closes, int fast, int slow, int signal)`
- 반환값: `{ macdLine, signalLine, histogram }`
- 기본값: fast=12, slow=26, signal=9
- 워밍업: 3 × slow 봉 필요 (26일 기준 78봉)

**MacdResult 구조:**
```java
public class MacdResult {
    private List<Double> macdLine;
    private List<Double> signalLine;
    private List<Double> histogram;
}
```

**4) ADX (Average Directional Index)**
- 파일: `AdxCalculator.java`
- 메서드: `static List<Double> calculate(List<Candle> candles, int length)`
- 알고리즘: Wilder's smoothing
- 기본값: length=14
- 워밍업: 4 × length 봉 필요 (14일 기준 56봉)

**5) Donchian Channel**
- 파일: `DonchianCalculator.java`
- 메서드: `static DonchianResult calculate(List<Candle> candles, int length)`
- 반환값: `{ high, low }`
- 워밍업: length + 1 봉 필요

**DonchianResult 구조:**
```java
public class DonchianResult {
    private List<Double> high;  // N일 최고가
    private List<Double> low;   // N일 최저가
}
```

**6) ATR (Average True Range)**
- 파일: `AtrCalculator.java`
- 메서드: `static List<Double> calculate(List<Candle> candles, int length)`
- 알고리즘: Wilder's smoothing
- 기본값: length=14
- 워밍업: 3 × length 봉 필요 (42봉)

**7) Volume MA**
- 파일: `VolumeMaCalculator.java`
- 메서드: `static List<Double> calculate(List<Double> volumes, int length)`
- 알고리즘: Simple Moving Average
- 기본값: length=20

---

### 1-3. 전략 엔진 구현

**파일 위치:** `src/main/java/com/cryptobot/upbit/strategy/`

#### Strategy 인터페이스

**파일:** `Strategy.java`

```java
public interface Strategy {
    String getCode();  // "V1", "V2", "V3"
    String getName();  // 전략명
    SignalResult evaluate(String symbol, List<Candle> candles5m, List<Candle> candles15m);
}
```

#### SignalResult DTO

**파일:** `SignalResult.java`

```java
public class SignalResult {
    private SignalType signalType;              // BUY, SELL, NONE
    private List<String> reasonCodes;           // ["DON_BREAK_UP", "VOL_CONFIRM"]
    private Map<String, Object> indicatorSnapshot;  // 지표값 스냅샷
    private LocalDateTime candleTime;           // 마감 봉 시각
    private Double entryPrice;                  // 진입가
    private Double stopPrice;                   // 손절가
    private Double targetPrice;                 // 목표가
}
```

**SignalType enum:**
```java
public enum SignalType {
    BUY, SELL, NONE
}
```

---

#### V1: Donchian Breakout 전략

**파일:** `StrategyV1Donchian.java`

**전략 코드:** "V1"  
**전략명:** "Donchian Breakout"

**사용 지표:**
- Donchian Channel (entry=20, exit=10)
- Volume MA (length=20)
- ATR (length=14)

**파라미터:**
```java
- timeframe: 5m
- entryLength: 20
- exitLength: 10
- volumeConfirm: true
- volumeMultiplier: 1.2
- atrStop: true
- atrStopMultiplier: 1.5
- tpRatio: 2
```

**매수 조건 (BUY):**
1. `Close[t] > DonchianHigh(20)[t-1]`  → reasonCode: `DON_BREAK_UP`
2. `Volume[t] >= 1.2 * VolumeMA20[t]` → reasonCode: `VOL_CONFIRM`

**매수 시 계산:**
```java
entry = Close[t]
stop = entry - 1.5 * ATR14[t]
target = entry + 2 * (entry - stop)
```

**매도 조건 (SELL):**
1. `Close[t] < DonchianLow(10)[t-1]`  → reasonCode: `DON_BREAK_DOWN`
2. `Low[t] <= stop`                   → reasonCode: `STOP_HIT`
3. `High[t] >= target`                → reasonCode: `TP_HIT`

**indicatorSnapshot 저장 항목:**
```java
{
  "close": Close[t],
  "donHigh": DonchianHigh[t-1],
  "donLow": DonchianLow[t-1],
  "volume": Volume[t],
  "volumeMA": VolumeMA20[t],
  "atr": ATR14[t]
}
```

---

#### V2: Holy Grail Pullback 전략

**파일:** `StrategyV2Pullback.java`

**전략 코드:** "V2"  
**전략명:** "Holy Grail Pullback"

**사용 지표:**
- EMA (length=20)
- ADX (length=14)
- 15분봉 필터

**파라미터:**
```java
- entryTimeframe: 5m
- filterTimeframe: 15m
- emaLength: 20
- adxLength: 14
- adxThreshold: 25
- pullbackTolerancePct: 0.2  // 0.2%
- expireBars: 10
```

**전략 상태 (Symbol별 유지):**
```java
- pullbackActive: boolean
- pullbackHigh: Double
- pullbackStartIndex: int
```

**매수 조건 (3단계):**

**Step A) 환경 필터 (15분봉):**
1. `ADX15[t] >= 25` → reasonCode: `ADX_STRONG`
2. (옵션) `Close15[t] > EMA15[t]` → reasonCode: `TREND_UP`

**Step B) 눌림 감지 (5분봉):**
```java
distancePct = abs(Close5[t] - EMA5[t]) / EMA5[t] * 100
if (distancePct <= 0.2) {
    pullbackActive = true
    pullbackHigh = High5[t]
    pullbackStartIndex = t
}
```
→ reasonCode: `PULLBACK_NEAR_EMA`

**Step C) 트리거 (진입):**
```java
if (pullbackActive && Close5[t] > pullbackHigh) {
    BUY 신호 발생
    pullbackActive = false
}
```
→ reasonCode: `BREAK_PULLBACK_HIGH`

**Step D) 만료:**
```java
if (t - pullbackStartIndex > expireBars) {
    pullbackActive = false
}
```

**매도 조건 (SELL):**
1. `Close5[t] < EMA5[t]` → reasonCode: `CLOSE_BELOW_EMA`
2. (옵션) ATR 기반 stop/tp

**indicatorSnapshot 저장 항목:**
```java
{
  "adx15": ADX15[t],
  "ema15": EMA15[t],
  "close15": Close15[t],
  "ema5": EMA5[t],
  "close5": Close5[t],
  "distancePct": distancePct,
  "pullbackHigh": pullbackHigh,
  "pullbackActive": pullbackActive
}
```

---

#### V3: Reversal 전략

**파일:** `StrategyV3Reversal.java`

**전략 코드:** "V3"  
**전략명:** "Reversal"

**사용 지표:**
- EMA (length=25)
- RSI (length=14)
- MACD Histogram (fast=12, slow=26, signal=9)
- ATR (length=14)

**파라미터:**
```java
- timeframe: 5m
- emaLength: 25
- gapPctThreshold: 20.0
- rsiLength: 14
- rsiOversold: 30
- macdFast: 12
- macdSlow: 26
- macdSignal: 9
- atrLength: 14
- atrStopMultiplier: 1.5
- tpRatio: 3
```

**매수 조건 (BUY) - 3가지 모두 충족:**

**조건 A: EMA 이격**
```java
gapPct = (EMA25[t] - Close[t]) / EMA25[t] * 100
if (gapPct >= 20.0) → reasonCode: "GAP_OK"
```

**조건 B: RSI 과매도**
```java
if (RSI14[t] <= 30) → reasonCode: "RSI_OVERSOLD"
```

**조건 C: MACD Histogram 녹색 전환**
```java
Histogram[t] = MACDLine[t] - SignalLine[t]
if (Histogram[t-1] <= 0 && Histogram[t] > 0) → reasonCode: "HIST_CROSS_UP"
```

**매수 시 계산:**
```java
entry = Close[t]
stop = entry - 1.5 * ATR14[t]
target = entry + 3 * (entry - stop)  // 3R
```

**매도 조건 (SELL) - 우선순위 청산:**
1. `Low[t] <= stop`                           → reasonCode: `STOP_HIT`
2. `High[t] >= target`                        → reasonCode: `TP_HIT`
3. `Histogram[t-1] >= 0 && Histogram[t] < 0` → reasonCode: `HIST_CROSS_DOWN_EXIT`

**indicatorSnapshot 저장 항목:**
```java
{
  "close": Close[t],
  "ema25": EMA25[t],
  "gapPct": gapPct,
  "rsi14": RSI14[t],
  "macdLine": MACDLine[t],
  "signalLine": SignalLine[t],
  "histogram": Histogram[t],
  "histogramPrev": Histogram[t-1],
  "atr14": ATR14[t],
  "stop": stop,
  "target": target
}
```

---

### 1-4. 신호 스캐너 서비스

**파일 위치:** `src/main/java/com/cryptobot/upbit/scanner/SignalScanner.java`

```java
@Service
public class SignalScanner {
    
    private final UpbitApiClient upbitApiClient;
    private final Map<String, Strategy> strategies;
    
    @Autowired
    public SignalScanner(
        UpbitApiClient upbitApiClient,
        StrategyV1Donchian strategyV1,
        StrategyV2Pullback strategyV2,
        StrategyV3Reversal strategyV3
    ) {
        this.upbitApiClient = upbitApiClient;
        this.strategies = Map.of(
            "V1", strategyV1,
            "V2", strategyV2,
            "V3", strategyV3
        );
    }
    
    public List<SignalScanResult> scanMarkets(String strategyCode, String timeframe) {
        // 1. 전체 KRW 마켓 조회
        List<UpbitMarketResponse> markets = upbitApiClient.getMarketAll();
        
        // 2. 선택된 전략 가져오기
        Strategy strategy = strategies.get(strategyCode);
        
        // 3. 각 마켓별로 캔들 데이터 수집 및 신호 평가
        List<SignalScanResult> results = new ArrayList<>();
        
        for (UpbitMarketResponse market : markets) {
            // 캔들 데이터 수집
            List<Candle> candles5m = upbitApiClient.getCandles(market.getMarket(), 5, 200);
            List<Candle> candles15m = upbitApiClient.getCandles(market.getMarket(), 15, 200);
            
            // 워밍업 체크
            if (!hasEnoughData(candles5m, strategyCode)) {
                continue;
            }
            
            // 전략 평가
            SignalResult signal = strategy.evaluate(market.getMarket(), candles5m, candles15m);
            
            // 결과 생성
            if (signal.getSignalType() != SignalType.NONE) {
                SignalScanResult result = createScanResult(market, candles5m, signal);
                results.add(result);
            }
        }
        
        return results;
    }
    
    private boolean hasEnoughData(List<Candle> candles, String strategyCode) {
        int required = switch(strategyCode) {
            case "V1" -> 78;  // MACD 워밍업
            case "V2" -> 56;  // ADX 워밍업
            case "V3" -> 78;  // MACD 워밍업
            default -> 100;
        };
        return candles.size() >= required;
    }
}
```

---

#### SignalScanResult DTO

**파일:** `src/main/java/com/cryptobot/upbit/scanner/dto/SignalScanResult.java`

```java
public class SignalScanResult {
    private String market;              // "KRW-BTC"
    private String coinName;            // "비트코인"
    private Double currentPrice;        // 현재가
    private Double changeRate;          // 전일대비 %
    private SignalType signal;          // BUY, SELL, NONE
    private List<String> reasonCodes;   // 신호 근거 코드
    private Map<String, Object> indicators;  // 주요 지표값
    private LocalDateTime scanTime;     // 스캔 시각
    
    // Getters, Setters, Builder
}
```

---

### 1-5. REST API 컨트롤러

**파일:** `src/main/java/com/cryptobot/upbit/scanner/controller/ScanController.java`

```java
@RestController
@RequestMapping("/api/scan")
@RequiredArgsConstructor
public class ScanController {
    
    private final SignalScanner signalScanner;
    
    @GetMapping("/signals")
    public ResponseEntity<ApiResponse<List<SignalScanResult>>> scanSignals(
        @RequestParam(defaultValue = "V1") String strategy,
        @RequestParam(defaultValue = "5m") String timeframe
    ) {
        try {
            List<SignalScanResult> results = signalScanner.scanMarkets(strategy, timeframe);
            return ResponseEntity.ok(ApiResponse.success(results));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("스캔 실패: " + e.getMessage()));
        }
    }
    
    @GetMapping("/strategies")
    public ResponseEntity<ApiResponse<List<StrategyInfo>>> getStrategies() {
        List<StrategyInfo> strategies = List.of(
            new StrategyInfo("V1", "Donchian Breakout", "돌파형 전략"),
            new StrategyInfo("V2", "Holy Grail Pullback", "눌림목 전략"),
            new StrategyInfo("V3", "Reversal", "반전 전략")
        );
        return ResponseEntity.ok(ApiResponse.success(strategies));
    }
}
```

**StrategyInfo DTO:**
```java
public class StrategyInfo {
    private String code;
    private String name;
    private String description;
}
```

---

### 1-6. 공통 DTO

**파일:** `src/main/java/com/cryptobot/upbit/common/dto/ApiResponse.java`

```java
@Getter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private String message;
    
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null);
    }
    
    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, null, message);
    }
}
```

---

### 1-7. Candle 엔티티/DTO

**파일:** `src/main/java/com/cryptobot/upbit/domain/candle/entity/Candle.java`

```java
public class Candle {
    private String market;
    private LocalDateTime candleDateTimeKst;
    private Double openingPrice;
    private Double highPrice;
    private Double lowPrice;
    private Double tradePrice;           // Close
    private Double candleAccTradeVolume;  // Volume
    
    // Getters, Setters, Builder
    
    // 편의 메서드
    public Double getClose() {
        return tradePrice;
    }
    
    public Double getVolume() {
        return candleAccTradeVolume;
    }
}
```

---

## 2. 프론트엔드 구현

### 2-1. API 서비스

**파일:** `frontend/src/services/scanService.js`

```javascript
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:9090';

export const scanService = {
  /**
   * 신호 스캔 실행
   * @param {string} strategy - 전략 코드 (V1/V2/V3)
   * @param {string} timeframe - 시간봉 (5m/15m/30m/1d)
   * @returns {Promise<Array>} 스캔 결과 리스트
   */
  async getSignals(strategy = 'V1', timeframe = '5m') {
    try {
      const response = await axios.get(`${API_BASE_URL}/api/scan/signals`, {
        params: { strategy, timeframe },
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      return response.data.data;
    } catch (error) {
      console.error('신호 스캔 실패:', error);
      throw error;
    }
  },

  /**
   * 사용 가능한 전략 목록 조회
   * @returns {Promise<Array>} 전략 리스트
   */
  async getStrategies() {
    try {
      const response = await axios.get(`${API_BASE_URL}/api/scan/strategies`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      return response.data.data;
    } catch (error) {
      console.error('전략 목록 조회 실패:', error);
      throw error;
    }
  }
};
```

---

### 2-2. 매매스캔 페이지 개선

**파일:** `frontend/src/pages/ScanPage.jsx` (또는 해당 컴포넌트 파일)

**추가/수정할 기능:**

#### 1) State 관리
```javascript
const [strategy, setStrategy] = useState('V1');
const [timeframe, setTimeframe] = useState('5m');
const [scanResults, setScanResults] = useState([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
```

#### 2) 전략 선택 드롭다운
```jsx
<select 
  value={strategy} 
  onChange={(e) => setStrategy(e.target.value)}
  className="bg-gray-800 text-white px-4 py-2 rounded"
>
  <option value="V1">V1: Donchian Breakout</option>
  <option value="V2">V2: Holy Grail Pullback</option>
  <option value="V3">V3: Reversal</option>
</select>
```

#### 3) 시간봉 선택 드롭다운
```jsx
<select 
  value={timeframe} 
  onChange={(e) => setTimeframe(e.target.value)}
  className="bg-gray-800 text-white px-4 py-2 rounded"
>
  <option value="5m">5분봉</option>
  <option value="15m">15분봉</option>
  <option value="30m">30분봉</option>
  <option value="1d">일봉</option>
</select>
```

#### 4) 검색 버튼 및 스캔 실행
```javascript
const handleScan = async () => {
  setLoading(true);
  setError(null);
  
  try {
    const results = await scanService.getSignals(strategy, timeframe);
    setScanResults(results);
  } catch (err) {
    setError('스캔 중 오류가 발생했습니다.');
    console.error(err);
  } finally {
    setLoading(false);
  }
};
```

```jsx
<button 
  onClick={handleScan}
  disabled={loading}
  className="bg-purple-600 hover:bg-purple-700 text-white px-6 py-2 rounded"
>
  {loading ? '스캔 중...' : '검색'}
</button>
```

#### 5) 로딩 상태 표시
```jsx
{loading && (
  <div className="flex justify-center items-center py-8">
    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
    <span className="ml-3 text-gray-400">종목 스캔 중...</span>
  </div>
)}
```

#### 6) 스캔 결과 테이블
```jsx
<table className="w-full">
  <thead className="bg-gray-800">
    <tr>
      <th className="px-4 py-3 text-left">코인명</th>
      <th className="px-4 py-3 text-right">현재가</th>
      <th className="px-4 py-3 text-right">전일대비</th>
      <th className="px-4 py-3 text-center">신호</th>
      <th className="px-4 py-3 text-center">매매</th>
    </tr>
  </thead>
  <tbody>
    {scanResults.map((result, index) => (
      <tr key={index} className="border-b border-gray-700 hover:bg-gray-800">
        <td className="px-4 py-3 flex items-center">
          <div className="w-8 h-8 bg-gray-700 rounded-full flex items-center justify-center mr-2">
            {result.coinName.charAt(0)}
          </div>
          {result.coinName}
        </td>
        <td className="px-4 py-3 text-right">
          {result.currentPrice.toLocaleString()}
        </td>
        <td className={`px-4 py-3 text-right ${
          result.changeRate >= 0 ? 'text-green-500' : 'text-red-500'
        }`}>
          {result.changeRate >= 0 ? '+' : ''}{result.changeRate.toFixed(2)}%
        </td>
        <td className="px-4 py-3 text-center">
          <div className={`w-3 h-3 rounded-full mx-auto ${
            result.signal === 'BUY' ? 'bg-red-500' :
            result.signal === 'SELL' ? 'bg-blue-500' :
            'bg-gray-500'
          }`}></div>
        </td>
        <td className="px-4 py-3 text-center">
          {result.signal === 'BUY' && (
            <button className="bg-red-500 hover:bg-red-600 text-white px-4 py-1 rounded">
              매수
            </button>
          )}
          {result.signal === 'SELL' && (
            <button className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-1 rounded">
              매도
            </button>
          )}
        </td>
      </tr>
    ))}
  </tbody>
</table>
```

#### 7) 신호 근거 표시 (툴팁 또는 상세 정보)
```jsx
<td className="px-4 py-3 text-sm text-gray-400">
  {result.reasonCodes.join(', ')}
</td>
```

---

## 3. 데이터 흐름 다이어그램

```
[프론트엔드 - 매매스캔 페이지]
  ↓
  전략 선택: V1/V2/V3
  시간봉 선택: 5m/15m/30m/1d
  ↓
  [검색 버튼 클릭]
  ↓
[HTTP GET /api/scan/signals?strategy=V1&timeframe=5m]
  ↓
[ScanController]
  ↓
[SignalScanner.scanMarkets()]
  ↓
  ┌─────────────────────────────────┐
  │ 1. 마켓 코드 조회                │
  │    UpbitApiClient.getMarketAll() │
  │    → KRW-BTC, KRW-ETH, ...      │
  └─────────────────────────────────┘
  ↓
  ┌─────────────────────────────────┐
  │ 2. 각 종목별 캔들 수집 (반복)    │
  │    for each market:              │
  │    - getCandles(market, 5, 200)  │
  │    - getCandles(market, 15, 200) │
  └─────────────────────────────────┘
  ↓
  ┌─────────────────────────────────┐
  │ 3. 워밍업 데이터 체크            │
  │    hasEnoughData() 확인          │
  │    부족하면 SKIP                 │
  └─────────────────────────────────┘
  ↓
  ┌─────────────────────────────────┐
  │ 4. 지표 계산                     │
  │    - EMA, RSI, MACD 등          │
  │    IndicatorEngine 사용          │
  └─────────────────────────────────┘
  ↓
  ┌─────────────────────────────────┐
  │ 5. 전략 평가                     │
  │    Strategy.evaluate()           │
  │    → SignalResult 생성           │
  └─────────────────────────────────┘
  ↓
  ┌─────────────────────────────────┐
  │ 6. 신호 결과 수집                │
  │    BUY/SELL 신호만 필터링        │
  │    SignalScanResult 생성         │
  └─────────────────────────────────┘
  ↓
[JSON 응답 반환]
  ↓
[프론트엔드 테이블에 표시]
```

---

## 4. 중요 구현 사항

### 4-1. 워밍업 데이터 요구사항

각 지표별 최소 필요 봉 수:
- EMA(25): **75봉** (3 × 25)
- RSI(14): **42봉** (3 × 14)
- MACD(26): **78봉** (3 × 26)
- ADX(14): **56봉** (4 × 14)
- Donchian(20): **21봉** (20 + 1)
- ATR(14): **42봉** (3 × 14)

**워밍업 체크 로직:**
```java
if (candles.size() < requiredCandles) {
    log.warn("SKIP_WARMUP_NOT_READY - market: {}, required: {}, actual: {}", 
        market, requiredCandles, candles.size());
    return SignalResult.none();
}
```

---

### 4-2. MACD Histogram 계산 (중요!)

**정확한 수식:**
```java
// 1. Fast EMA
List<Double> emaFast = EmaCalculator.calculate(closes, 12);

// 2. Slow EMA
List<Double> emaSlow = EmaCalculator.calculate(closes, 26);

// 3. MACD Line = Fast - Slow
List<Double> macdLine = subtract(emaFast, emaSlow);

// 4. Signal Line = EMA(MACD, 9)
List<Double> signalLine = EmaCalculator.calculate(macdLine, 9);

// 5. Histogram = MACD Line - Signal Line
List<Double> histogram = subtract(macdLine, signalLine);
```

**녹색 전환 감지:**
```java
// t-1 봉: 음수 또는 0
// t 봉: 양수
boolean crossUp = histogram.get(t-1) <= 0 && histogram.get(t) > 0;
```

---

### 4-3. 에러 처리 및 로깅

#### API 호출 실패 처리
```java
@Retryable(
    value = {RestClientException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000)
)
public List<Candle> getCandles(String market, int minutes, int count) {
    try {
        // API 호출
    } catch (Exception e) {
        log.error("ERR_DATA_FETCH - market: {}, error: {}", market, e.getMessage());
        throw e;
    }
}
```

#### 지표 계산 실패 처리
```java
try {
    List<Double> rsi = RsiCalculator.calculate(closes, 14);
} catch (Exception e) {
    log.error("ERR_INDICATOR_CALC - indicator: RSI, error: {}", e.getMessage());
    return SignalResult.none();
}
```

---

### 4-4. 업비트 API 레이트 리미팅

**제한:** 초당 10회, 분당 600회

**대응 방법:**

**방법 1: 순차 처리 + Delay**
```java
for (String market : markets) {
    List<Candle> candles = getCandles(market, 5, 200);
    Thread.sleep(100); // 100ms 대기 → 초당 10회 제한 준수
}
```

**방법 2: 병렬 처리 + Rate Limiter**
```java
RateLimiter rateLimiter = RateLimiter.create(10.0); // 초당 10회

markets.parallelStream()
    .map(market -> {
        rateLimiter.acquire();
        return getCandles(market, 5, 200);
    })
    .collect(Collectors.toList());
```

---

### 4-5. 캐시 구현 (선택사항, 성능 향상)

**Redis 또는 In-Memory Cache 사용**

```java
@Cacheable(value = "candles", key = "#market + '_' + #minutes")
public List<Candle> getCandles(String market, int minutes, int count) {
    // API 호출
}

// 5분마다 캐시 갱신
@Scheduled(fixedRate = 300000) // 5분 = 300,000ms
@CacheEvict(value = "candles", allEntries = true)
public void evictCandleCache() {
    log.info("Candle cache evicted");
}
```

---

## 5. 테스트 구현

### 5-1. 단위 테스트

#### EmaCalculatorTest
```java
@Test
void testEmaCalculation() {
    List<Double> prices = List.of(100.0, 102.0, 101.0, 103.0, 105.0);
    List<Double> ema = EmaCalculator.calculate(prices, 3);
    
    assertNotNull(ema);
    assertTrue(ema.size() > 0);
    // 추가 검증
}
```

#### MacdCalculatorTest
```java
@Test
void testMacdHistogramCrossUp() {
    // Given: 히스토그램이 음→양 전환하는 데이터
    List<Double> closes = createTestData();
    
    // When
    MacdResult result = MacdCalculator.calculate(closes, 12, 26, 9);
    
    // Then
    List<Double> histogram = result.getHistogram();
    int lastIdx = histogram.size() - 1;
    
    assertTrue(histogram.get(lastIdx - 1) <= 0);
    assertTrue(histogram.get(lastIdx) > 0);
}
```

---

### 5-2. 통합 테스트

#### UpbitApiClientTest
```java
@SpringBootTest
class UpbitApiClientTest {
    
    @Autowired
    private UpbitApiClient upbitApiClient;
    
    @Test
    void testGetMarketAll() {
        List<UpbitMarketResponse> markets = upbitApiClient.getMarketAll();
        
        assertNotNull(markets);
        assertTrue(markets.size() > 0);
        assertTrue(markets.get(0).getMarket().startsWith("KRW-"));
    }
    
    @Test
    void testGetCandles() {
        List<Candle> candles = upbitApiClient.getCandles("KRW-BTC", 5, 200);
        
        assertNotNull(candles);
        assertEquals(200, candles.size());
        assertTrue(candles.get(0).getClose() > 0);
    }
}
```

#### SignalScannerTest
```java
@SpringBootTest
class SignalScannerTest {
    
    @Autowired
    private SignalScanner signalScanner;
    
    @Test
    void testScanMarketsV1() {
        List<SignalScanResult> results = signalScanner.scanMarkets("V1", "5m");
        
        assertNotNull(results);
        // 신호가 있을 수도, 없을 수도 있음
        results.forEach(result -> {
            assertNotNull(result.getMarket());
            assertNotNull(result.getSignal());
            assertTrue(result.getCurrentPrice() > 0);
        });
    }
}
```

---

## 6. application.yml 설정 추가

```yaml
upbit:
  api:
    base-url: https://api.upbit.com/v1
    timeout: 5000          # 5초
    retry:
      max-attempts: 3
      delay: 1000          # 1초
    rate-limit:
      per-second: 10
      per-minute: 600

# 스캔 스케줄러 (선택사항)
scanner:
  enabled: false           # 자동 스캔 비활성화 (수동 실행만)
  cron: "0 */5 * * * *"   # 5분마다 실행
  strategy: "V1"           # 기본 전략

# 로깅 레벨
logging:
  level:
    com.cryptobot.upbit.upbit: DEBUG
    com.cryptobot.upbit.indicator: DEBUG
    com.cryptobot.upbit.strategy: DEBUG
    com.cryptobot.upbit.scanner: INFO
```

---

## 7. 의존성 추가 (build.gradle 또는 pom.xml)

### Gradle 기준

```gradle
dependencies {
    // 기존 dependencies...
    
    // WebClient (비동기 HTTP)
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    
    // Retry 기능
    implementation 'org.springframework.retry:spring-retry'
    implementation 'org.springframework:spring-aspects'
    
    // Rate Limiter (선택사항)
    implementation 'com.google.guava:guava:31.1-jre'
    
    // 캐시 (선택사항)
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    implementation 'com.github.ben-manes.caffeine:caffeine'
}
```

---

## 8. 구현 체크리스트

### 백엔드
- [ ] UpbitApiClient 구현
- [ ] UpbitMarketResponse DTO
- [ ] UpbitCandleResponse DTO
- [ ] Candle 엔티티
- [ ] EmaCalculator
- [ ] RsiCalculator
- [ ] MacdCalculator
- [ ] AdxCalculator
- [ ] DonchianCalculator
- [ ] AtrCalculator
- [ ] VolumeMaCalculator
- [ ] IndicatorEngine
- [ ] Strategy 인터페이스
- [ ] SignalResult DTO
- [ ] StrategyV1Donchian
- [ ] StrategyV2Pullback
- [ ] StrategyV3Reversal
- [ ] SignalScanner 서비스
- [ ] SignalScanResult DTO
- [ ] ScanController
- [ ] ApiResponse 공통 DTO
- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성

### 프론트엔드
- [ ] scanService.js API 서비스
- [ ] ScanPage 전략 선택 드롭다운
- [ ] ScanPage 시간봉 선택 드롭다운
- [ ] ScanPage 검색 버튼
- [ ] ScanPage 로딩 상태 UI
- [ ] ScanPage 스캔 결과 테이블
- [ ] 신호등 아이콘 표시
- [ ] 매수/매도 버튼
- [ ] 에러 처리 UI

---

## 9. 최종 확인 사항

### 구현 완료 후 테스트

1. **백엔드 API 테스트**
   ```bash
   # Postman 또는 curl로 테스트
   curl -X GET "http://localhost:9090/api/scan/signals?strategy=V1&timeframe=5m" \
     -H "Authorization: Bearer {JWT_TOKEN}"
   ```

2. **프론트엔드 화면 테스트**
   - 전략 선택 → 검색 버튼 → 결과 표시
   - 로딩 상태 확인
   - 에러 처리 확인

3. **성능 테스트**
   - 전체 스캔 소요 시간 측정 (목표: 2분 이내)
   - 메모리 사용량 확인

4. **정확도 검증**
   - 실제 업비트 차트와 신호 비교
   - 지표값 정확도 확인

---

## 10. 참고 문서

### 업비트 API 문서
- https://docs.upbit.com/reference

### 지표 계산 참고
- TradingView Pine Script 문서
- TA-Lib 라이브러리

---

# 구현 시작!

위 명세를 바탕으로 모든 파일을 생성하고 구현해주세요.
각 파일은 실제 동작 가능한 완전한 코드로 작성되어야 합니다.
특히 지표 계산 로직은 수학적으로 정확해야 하며, 워밍업 데이터 체크를 반드시 포함해주세요.
